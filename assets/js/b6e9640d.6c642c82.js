"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7390],{3905:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>h});var o=n(7294);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function r(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,o,a=function(t,e){if(null==t)return{};var n,o,a={},i=Object.keys(t);for(o=0;o<i.length;o++)n=i[o],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(o=0;o<i.length;o++)n=i[o],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var l=o.createContext({}),c=function(t){var e=o.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):r(r({},e),t)),n},p=function(t){var e=c(t.components);return o.createElement(l.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return o.createElement(o.Fragment,{},e)}},d=o.forwardRef((function(t,e){var n=t.components,a=t.mdxType,i=t.originalType,l=t.parentName,p=s(t,["components","mdxType","originalType","parentName"]),d=c(n),h=a,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||i;return n?o.createElement(m,r(r({ref:e},p),{},{components:n})):o.createElement(m,r({ref:e},p))}));function h(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var i=n.length,r=new Array(i);r[0]=d;var s={};for(var l in e)hasOwnProperty.call(e,l)&&(s[l]=e[l]);s.originalType=t,s.mdxType="string"==typeof t?t:a,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9880:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>p,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>u});var o=n(7462),a=n(3366),i=(n(7294),n(3905)),r=["components"],s={id:"lifecycle",title:"Transaction validation lifecycle"},l=void 0,c={unversionedId:"essays/lifecycle",id:"essays/lifecycle",title:"Transaction validation lifecycle",description:"Transactions are the most fundamental entities for interacting with Nervos CKB. When you interact with the CKB, you are submitting state transitions through transactions. This document will explain the lifecycle of CKB transaction validation.",source:"@site/docs/essays/lifecycle.mdx",sourceDirName:"essays",slug:"/essays/lifecycle",permalink:"/docs/essays/lifecycle",draft:!1,editUrl:"https://github.com/nervosnetwork/docs-new/tree/develop/website/docs/essays/lifecycle.mdx",tags:[],version:"current",frontMatter:{id:"lifecycle",title:"Transaction validation lifecycle"},sidebar:"defaultSidebar",previous:{title:"Introduction to CKB Studio",permalink:"/docs/essays/introduction-to-ckb-studio"},next:{title:"Mint SUDT via Contract",permalink:"/docs/essays/mint-sudt-via-contract"}},p={},u=[{value:"Submit the transaction through RPC",id:"submit-the-transaction-through-rpc",level:2},{value:"Verification",id:"verification",level:2},{value:"STEP 1 \u2014 Resolve",id:"step-1--resolve",level:3},{value:"STEP 2 \u2014 Verify",id:"step-2--verify",level:3},{value:"Broadcast to the network",id:"broadcast-to-the-network",level:2},{value:"Tx-pool (mempool)",id:"tx-pool-mempool",level:2},{value:"Tx-pool Two-Step Transaction Confirmation",id:"tx-pool-two-step-transaction-confirmation",level:2}],d={toc:u};function h(t){var e=t.components,s=(0,a.Z)(t,r);return(0,i.kt)("wrapper",(0,o.Z)({},d,s,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Transactions are the most fundamental entities for interacting with Nervos CKB. When you interact with the CKB, you are submitting state transitions through transactions. This document will explain the lifecycle of CKB transaction validation."),(0,i.kt)("img",{src:n(2881).Z,width:"300"}),(0,i.kt)("h2",{id:"submit-the-transaction-through-rpc"},"Submit the transaction through RPC"),(0,i.kt)("p",null,"First, a sender constructs a transaction, then submits it through RPC. The transaction will be validated by the ",(0,i.kt)("inlineCode",{parentName:"p"},"outputs_validator"),"  (introduced in v0.27.0) which has been submitted. "),(0,i.kt)("p",null,"The default validation logic involves checking various things:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'transaction.outputs.all{ |output|\n    let script = output.script\n    (script.code_hash == secp256k1_blake160_sighash_all && script.hash_type == "type" && script.args.size == 20) ||\n    (script.code_hash == secp256k1_blake160_multisig_all && script.hash_type == "type" && \uff08script.args.size == 20 || (script.args.size == 28 && script.args[20..28].is_valid_since_format))\n}\ntransaction.outputs.all{ |output|\n    let script = output.type\n    script.is_null || script.code_hash == dao && script.hash_type == "type"\n    || (script.has_lock_period() && since.is_absolute())\n}\n')),(0,i.kt)("p",null,"This validation is intended to prevent improperly constructed transactions, such as mentioned in ",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"https://github.com/nervosnetwork/ckb/wiki/Common-Gotchas#nervos-dao"},"https://github.com/nervosnetwork/ckb/wiki/Common-Gotchas#nervos-dao"))," "),(0,i.kt)("p",null,"Although the node can be configured to ",(0,i.kt)("inlineCode",{parentName:"p"},"passthrough")," to skip this validation, once the transaction has been submitted to your local node, the node also exports the transaction id, which can then be used to track transaction status."),(0,i.kt)("h2",{id:"verification"},"Verification"),(0,i.kt)("p",null,"Before the transaction is broadcasted and enters into the mempool, it should be verified and executed locally."),(0,i.kt)("h3",{id:"step-1--resolve"},"STEP 1 \u2014 Resolve"),(0,i.kt)("p",null,"Essentially, transaction inputs are just pointers, as shown here:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"struct OutPoint {\n    tx_hash:        Byte32,\n    index:          Uint32,\n}\n")),(0,i.kt)("p",null,"We gather the referenced data through the pointer prior to transaction execution, this process is called \u201cresolve transaction\u201d. We will also need to check that all inputs of this transaction are valid (no duplicate or double-spending)."),(0,i.kt)("h3",{id:"step-2--verify"},"STEP 2 \u2014 Verify"),(0,i.kt)("p",null,"The process of verification involves checking the following items:       "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"version (currently must be 0) "),(0,i.kt)("li",{parentName:"ol"},"serialized_size is less than limit ",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"pub fn serialized_size(&self) -> usize {\n// the offset in TransactionVec header is u32\nself.as_slice().len() + molecule::NUMBER_SIZE\n// molecule::NUMBER_SIZE = ",(0,i.kt)("inlineCode",{parentName:"li"},"size_of::<u32>() 4"),"\n}"))),(0,i.kt)("li",{parentName:"ol"},"inputs are not empty",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"inputs().is_empty() || outputs().is_empty()"))),(0,i.kt)("li",{parentName:"ol"},"inputs are mature",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"For each input and dep, if the referenced output transaction is a cellbase, it must have at least 4 epoch confirmations"))),(0,i.kt)("li",{parentName:"ol"},"capacity",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"sum of inputs\u2019 capacity must less than or equal to outputs\u2019 capacity"))),(0,i.kt)("li",{parentName:"ol"},"duplicate_deps",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"deps should not be duplicated"))),(0,i.kt)("li",{parentName:"ol"},"outputs_data_verifier",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"number of \u2018output data' fields must equal number of outputs"))),(0,i.kt)("li",{parentName:"ol"},"since     ",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"\u2018since\u2019 value must follow the rules described in ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0017-tx-valid-since/0017-tx-valid-since.md"},"https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0017-tx-valid-since/0017-tx-valid-since.md"))))),(0,i.kt)("p",null,"Then CKB VM will execute the transaction script and output the number of cycles consumed."),(0,i.kt)("h2",{id:"broadcast-to-the-network"},"Broadcast to the network"),(0,i.kt)("p",null,"If the verification is successful, the current node broadcasts the transaction (with cycles value) to all of its connected peer nodes. "),(0,i.kt)("p",null,"If verification fails, the transaction is not broadcasted anymore. The transaction flows through various \u201cfull nodes\u201d, which repeat the verification process described in the previous step, and check that the cycles value matches the actual cycles consumed when the transaction is verified."),(0,i.kt)("h2",{id:"tx-pool-mempool"},"Tx-pool (mempool)"),(0,i.kt)("img",{src:n(7434).Z,width:"600"}),(0,i.kt)("p",null,"CKB uses a two-step process for transaction confirmation. Transactions will be divided into different status (pending and proposed) in the tx-pool. The status of transactions will change when a block is added to the blockchain. When the latest block changes, all transactions in the tx-pool will be re-scanned to ensure they are still valid."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"BlockAssembler")," will fetch proposals and transactions from the pending pool and proposed pool for block template."),(0,i.kt)("p",null,"More information about this two-step transaction confirmation process can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0020-ckb-consensus-protocol/0020-ckb-consensus-protocol.md#two-step-transaction-confirmation"},"here"),"."),(0,i.kt)("h2",{id:"tx-pool-two-step-transaction-confirmation"},"Tx-pool Two-Step Transaction Confirmation"),(0,i.kt)("p",null,"Since CKB v0.101, the tx-pool will not\xa0run the two-step transaction confirmation mechanism for non-miner nodes, i.e. nodes that are not configured with block assembler, and the status of the transaction will not be displayed when the transaction is fetched via rpc."))}h.isMDXComponent=!0},2881:(t,e,n)=>{n.d(e,{Z:()=>o});const o=n.p+"assets/images/lifecycle-d38b91ad7e2b4a2b31425a2885bd62d0.png"},7434:(t,e,n)=>{n.d(e,{Z:()=>o});const o=n.p+"assets/images/mempool-fca4ce93b85d56b6c08191cb272fa76f.png"}}]);